local Math = {
    raycast = workspace.FindPartOnRayWithIgnoreList,
    wraycast = workspace.FindPartOnRayWithWhitelist,
    dot = Vector3.new().Dot,
    e = 2.718281828459045,
    atan2 = math.atan2,
    cos = math.cos,
    sin = math.sin,
    err = 1.0E-10
}

local function solve(a, b, c, d, e)
    if not a then
        return
    elseif a > -Math.err and a < Math.err then
        return solve(b, c, d, e)
    end
    if e then
        local k = -b / (4 * a)
        local p = (8 * a * c - 3 * b * b) / (8 * a * a)
        local q = (b * b * b + 8 * a * a * d - 4 * a * b * c) / (8 * a * a * a)
        local r = (16 * a * a * b * b * c + 256 * a * a * a * a * e - 3 * a * b * b * b * b - 64 * a * a * a * b * d) / (256 * a * a * a * a * a)
        local h0, h1, h2 = solve(1, 2 * p, p * p - 4 * r, -q * q)
        local s = h2 or h0
        if s < Math.err then
            local f0, f1 = solve(1, p, r)
            if not f1 or f1 < 0 then
                return
            else
                local f = f1 ^ 0.5
                return k - f, k + f
            end
        else
            local h = s ^ 0.5
            local f = (h * h * h + h * p - q) / (2 * h)
            if f > -Math.err and f < Math.err then
                return k - h, k
            else
                local r0, r1 = solve(1, h, f)
                local r2, r3 = solve(1, -h, r / f)
                if r0 and r2 then
                    return k + r0, k + r1, k + r2, k + r3
                elseif r0 then
                    return k + r0, k + r1
                elseif r2 then
                    return k + r2, k + r3
                else
                    return
                end
            end
        end
    elseif d then
        local k = -b / (3 * a)
        local p = (3 * a * c - b * b) / (9 * a * a)
        local q = (2 * b * b * b - 9 * a * b * c + 27 * a * a * d) / (54 * a * a * a)
        local r = p * p * p + q * q
        local s = r ^ 0.5 + q
        if s > -Math.err and s < Math.err then
            if q < 0 then
                return k + (-2 * q) ^ 0.3333333333333333
            else
                return k - (2 * q) ^ 0.3333333333333333
            end
        elseif r < 0 then
            local m = (-p) ^ 0.5
            local d = Math.atan2((-r) ^ 0.5, q) / 3
            local u = m * Math.cos(d)
            local v = m * Math.sin(d)
            return k - 2 * u, k + u - 1.7320508075688772 * v, k + u + 1.7320508075688772 * v
        elseif s < 0 then
            local m = -(-s) ^ 0.3333333333333333
            return k + p / m - m
        else
            local m = s ^ 0.3333333333333333
            return k + p / m - m
        end
    elseif c then
        local k = -b / (2 * a)
        local u2 = k * k - c / a
        if u2 < 0 then
            return
        else
            local u = u2 ^ 0.5
            return k - u, k + u
        end
    elseif b then
        return -b / a
    else
        return
    end
end
Math.solve = solve

function Math.minpos(t)
    for i, v in pairs(t) do
        if v and v >= 0 then
            return v
        end
    end
end

function Math.timehit(o, v, a, t)
	local d = o - t
	local st = 0
	local n = (1 / 0)

    for i, v in pairs({solve(Math.dot(a, a), 3 * Math.dot(a, v), 2 * (Math.dot(a, d) + Math.dot(v, v)), 2 * Math.dot(d, v))}) do
		local m = (d + v * v + v * v / 2 * a).magnitude

		if st < v and m < n then
			st = v
			n = m
		end
	end

	return st, n
end

function Math.trajectory(o, a, t, s)
	local ve = t - o
	local b = -a

    for i, v in pairs({solve(Math.dot(b, b) / 4, 0, Math.dot(b, ve) - s * s, 0, Math.dot(ve, ve))}) do
        if v and v > 0 then
            return b * v / 2 + ve / v, v
        end
    end
end

function Math.simple_trajectory(s, a, r)
    local a0 = 4 * Math.dot(r, r)
    local a1 = -4 * (Math.dot(a, r) + s * s)
    local a2 = Math.dot(a, a)
    local u = Math.minpos({solve(a2, a1, a0)})

    if u then
        local t = u ^ 0.5

        return r / t - t / 2 * a
    end
end

function Math.raycastSingleExit(o, t, i)
	local r = RaycastParams.new()
	r.FilterType = Enum.RaycastFilterType.Whitelist
	r.FilterDescendantsInstances = {i}
	r.IgnoreWater = true

	return workspace:Raycast(o + t, -t, r)
end

function Math.bulletcheck(o, t, p)
    local ve = t - o
    local n = ve.Unit
    local h, po = Math.raycast(workspace, Ray.new(o, ve), {workspace.Players, workspace.Camera, workspace.Ignore})

    if p <= 0.01 then
        return false
    end

    if h then
        if h.CanCollide and h.Transparency == 0 and h.Name ~= "Window" then
            local e = h.Size.Magnitude * n
            local nh, dp = Math.wraycast(workspace, Ray.new(po + e, -e), {h})
            local m = (dp - po).Magnitude

            if m >= p then

                return false
            else
                p = p - m
            end
        end

        return Math.bulletcheck(po + n / 100, t, p)
    else

        return true
    end
end

return Math
